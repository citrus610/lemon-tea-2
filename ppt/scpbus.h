#pragma once

#include <iostream>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <crtdbg.h>
#include <winioctl.h>
#include <INITGUID.H>
#include <Xinput.h>
#include <SetupAPI.h>
#pragma comment (lib, "SetupApi.lib")

typedef struct _BUSENUM_UNPLUG_HARDWARE 
{
	ULONG Size;
	ULONG SerialNo;
	ULONG Flags;
	ULONG Reserved[1];
}
BUSENUM_UNPLUG_HARDWARE, * PBUSENUM_UNPLUG_HARDWARE;

DEFINE_GUID(GUID_DEVINTERFACE_SCPVBUS, 0xf679f562, 0x3164, 0x42ce, 0xa4, 0xdb, 0xe7, 0xdd, 0xbe, 0x72, 0x39, 0x9);

#define VBOX_BUS
#define FEEDBACK_BUFFER_LENGTH 9
#define MAX_NUMBER_XBOX_CTRLS 4

#define AXIS_MAX	32767
#define AXIS_MIN	-32768


#define FILE_DEVICE_BUSENUM		FILE_DEVICE_BUS_EXTENDER
#define BUSENUM_IOCTL(_index_)	CTL_CODE(FILE_DEVICE_BUSENUM, _index_, METHOD_BUFFERED, FILE_READ_DATA)
#define BUSENUM_W_IOCTL(_index_)	CTL_CODE(FILE_DEVICE_BUSENUM, _index_, METHOD_BUFFERED, FILE_WRITE_DATA)
#define BUSENUM_R_IOCTL(_index_)	CTL_CODE(FILE_DEVICE_BUSENUM, _index_, METHOD_BUFFERED, FILE_READ_DATA)
#define BUSENUM_RW_IOCTL(_index_)	CTL_CODE(FILE_DEVICE_BUSENUM, _index_, METHOD_BUFFERED, FILE_WRITE_DATA | FILE_READ_DATA)

#define IOCTL_BUSENUM_BASE 0x801

#ifdef VBOX_BUS
#define IOCTL_BUSENUM_PLUGIN_HARDWARE	BUSENUM_W_IOCTL(IOCTL_BUSENUM_BASE+0x0)
#define IOCTL_BUSENUM_UNPLUG_HARDWARE	BUSENUM_W_IOCTL(IOCTL_BUSENUM_BASE+0x1)
#define IOCTL_BUSENUM_EJECT_HARDWARE	BUSENUM_W_IOCTL(IOCTL_BUSENUM_BASE+0x2)
#define IOCTL_BUSENUM_REPORT_HARDWARE	BUSENUM_RW_IOCTL(IOCTL_BUSENUM_BASE+0x3)
#else
#define IOCTL_BUSENUM_PLUGIN_HARDWARE	BUSENUM_IOCTL(0x0)
#define IOCTL_BUSENUM_UNPLUG_HARDWARE	BUSENUM_IOCTL(0x1)
#define IOCTL_BUSENUM_EJECT_HARDWARE	BUSENUM_IOCTL(0x2)
#define IOCTL_BUSENUM_REPORT_HARDWARE	BUSENUM_IOCTL(0x3)
#endif

#define IOCTL_BUSENUM_ISDEVPLUGGED	BUSENUM_RW_IOCTL(IOCTL_BUSENUM_BASE+0x100)
#define IOCTL_BUSENUM_EMPTY_SLOTS	BUSENUM_RW_IOCTL(IOCTL_BUSENUM_BASE+0x101)
#define IOCTL_BUSENUM_PROC_ID		BUSENUM_RW_IOCTL(IOCTL_BUSENUM_BASE+0x102)

class scpbus
{
public:
	XINPUT_GAMEPAD g_Gamepad[MAX_NUMBER_XBOX_CTRLS];
	BOOL g_vDevice[MAX_NUMBER_XBOX_CTRLS] = { FALSE, FALSE, FALSE, FALSE };
	HANDLE g_hBus = INVALID_HANDLE_VALUE;
public:
	BOOL is_bus_installed();
	int get_bus_path(LPCTSTR path, UINT size);
	HANDLE get_bus_handle(void);
	BOOL get_create_proc_ID(DWORD UserIndex, PULONG ProcID);
	BOOL set_xoutput_state(DWORD UserIndex, XINPUT_GAMEPAD* pGamepad);
	BOOL set_get_xoutput_state(DWORD UserIndex, XINPUT_GAMEPAD* pGamepad, PBYTE bVibrate, PBYTE bLargeMotor, PBYTE bSmallMotor, PBYTE bLed);
	WORD convert_button(LONG vBtns, WORD xBtns, UINT vBtn, UINT xBtn);
	BOOL unplug_opt(UINT UserIndex, BOOL Force);
};

